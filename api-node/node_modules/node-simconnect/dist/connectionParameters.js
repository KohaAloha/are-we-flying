"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.autodetectServerAddress = void 0;
const Path = require("path");
const os = require("os");
const debug_1 = require("debug");
const ini_1 = require("./utils/ini");
const registry_1 = require("./utils/registry");
const network_1 = require("./utils/network");
const logger = (0, debug_1.default)('node-simconnect');
function findSimConnectPortIPv4() {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const port = yield (0, registry_1.readRegistryValue)('HKCU\\Software\\Microsoft\\Microsoft Games\\Flight Simulator', 'SimConnect_Port_IPv4');
            if (!port) {
                throw new Error('Could not find SimConnect_Port_IPv4 in the Windows registry');
            }
            return parseInt(port, 10);
        }
        catch (_a) {
            return 2048;
        }
    });
}
function readNetworkConfigFromSimConnectCfg(folderPath, index) {
    return __awaiter(this, void 0, void 0, function* () {
        const filePath = Path.join(folderPath, 'SimConnect.cfg');
        let fullCfg;
        try {
            // SimConnect.cfg uses the INI fileformat
            fullCfg = yield (0, ini_1.readIniFile)(filePath);
        }
        catch (e) {
            logger('Could not read SimConnect.cfg due to to the following error:', e);
            return undefined;
        }
        if (fullCfg.SimConnect === undefined) {
            throw new Error(`Invalid SimConnect.cfg file: ${filePath}`);
        }
        const indexStr = index !== undefined ? index.toString(10) : '0';
        const cfg = fullCfg.SimConnect[indexStr] ? fullCfg.SimConnect[indexStr] : fullCfg.SimConnect;
        if (cfg.Protocol === undefined || cfg.Address === undefined || cfg.Port === undefined) {
            throw new Error(`The loaded SimConnect.cfg (${filePath}) is missing required parameters.`);
        }
        else if (cfg.Protocol && cfg.Protocol.toUpperCase() !== 'IPV4') {
            throw new Error('Only the Ipv4 protocol is supported at the moment');
        }
        return {
            type: 'ipv4',
            host: cfg.Address,
            port: parseInt(cfg.Port, 10),
        };
    });
}
function autodetectServerAddress(cfgIndex) {
    return __awaiter(this, void 0, void 0, function* () {
        // Check for SimConnect.cfg in current dir
        const localConfig = yield readNetworkConfigFromSimConnectCfg(process.cwd(), cfgIndex);
        if (localConfig)
            return localConfig;
        const homeConfig = yield readNetworkConfigFromSimConnectCfg(os.homedir(), cfgIndex);
        if (homeConfig)
            return homeConfig;
        if (cfgIndex !== undefined) {
            throw new Error(`No SimConnect.cfg file containing the given config index ${cfgIndex} was found`);
        }
        // Check if named pipe exist
        const PIPE = '\\\\.\\pipe\\Microsoft Flight Simulator\\SimConnect';
        const msfsSimconnectPipeOk = yield (0, network_1.checkIfNamedPipeExist)(PIPE);
        if (msfsSimconnectPipeOk) {
            return { type: 'pipe', address: PIPE };
        }
        // Read port number from Windows registry
        const ipv4port = yield findSimConnectPortIPv4();
        return { type: 'ipv4', host: 'localhost', port: ipv4port };
    });
}
exports.autodetectServerAddress = autodetectServerAddress;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29ubmVjdGlvblBhcmFtZXRlcnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvY29ubmVjdGlvblBhcmFtZXRlcnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QixpQ0FBMEI7QUFDMUIscUNBQTBDO0FBQzFDLCtDQUFxRDtBQUNyRCw2Q0FBd0Q7QUFFeEQsTUFBTSxNQUFNLEdBQUcsSUFBQSxlQUFLLEVBQUMsaUJBQWlCLENBQUMsQ0FBQztBQUV4QyxTQUFlLHNCQUFzQjs7UUFDakMsSUFBSTtZQUNBLE1BQU0sSUFBSSxHQUFHLE1BQU0sSUFBQSw0QkFBaUIsRUFDaEMsOERBQThELEVBQzlELHNCQUFzQixDQUN6QixDQUFDO1lBQ0YsSUFBSSxDQUFDLElBQUksRUFBRTtnQkFDUCxNQUFNLElBQUksS0FBSyxDQUFDLDZEQUE2RCxDQUFDLENBQUM7YUFDbEY7WUFDRCxPQUFPLFFBQVEsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUM7U0FDN0I7UUFBQyxXQUFNO1lBQ0osT0FBTyxJQUFJLENBQUM7U0FDZjtJQUNMLENBQUM7Q0FBQTtBQU1ELFNBQWUsa0NBQWtDLENBQzdDLFVBQWtCLEVBQ2xCLEtBQWM7O1FBRWQsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztRQUV6RCxJQUFJLE9BQU8sQ0FBQztRQUNaLElBQUk7WUFDQSx5Q0FBeUM7WUFDekMsT0FBTyxHQUFHLE1BQU0sSUFBQSxpQkFBVyxFQUFDLFFBQVEsQ0FBQyxDQUFDO1NBQ3pDO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDUixNQUFNLENBQUMsOERBQThELEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDMUUsT0FBTyxTQUFTLENBQUM7U0FDcEI7UUFFRCxJQUFJLE9BQU8sQ0FBQyxVQUFVLEtBQUssU0FBUyxFQUFFO1lBQ2xDLE1BQU0sSUFBSSxLQUFLLENBQUMsZ0NBQWdDLFFBQVEsRUFBRSxDQUFDLENBQUM7U0FDL0Q7UUFFRCxNQUFNLFFBQVEsR0FBRyxLQUFLLEtBQUssU0FBUyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUM7UUFDaEUsTUFBTSxHQUFHLEdBQUcsT0FBTyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQztRQUU3RixJQUFJLEdBQUcsQ0FBQyxRQUFRLEtBQUssU0FBUyxJQUFJLEdBQUcsQ0FBQyxPQUFPLEtBQUssU0FBUyxJQUFJLEdBQUcsQ0FBQyxJQUFJLEtBQUssU0FBUyxFQUFFO1lBQ25GLE1BQU0sSUFBSSxLQUFLLENBQUMsOEJBQThCLFFBQVEsbUNBQW1DLENBQUMsQ0FBQztTQUM5RjthQUFNLElBQUksR0FBRyxDQUFDLFFBQVEsSUFBSSxHQUFHLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBRSxLQUFLLE1BQU0sRUFBRTtZQUM5RCxNQUFNLElBQUksS0FBSyxDQUFDLG1EQUFtRCxDQUFDLENBQUM7U0FDeEU7UUFFRCxPQUFPO1lBQ0gsSUFBSSxFQUFFLE1BQU07WUFDWixJQUFJLEVBQUUsR0FBRyxDQUFDLE9BQU87WUFDakIsSUFBSSxFQUFFLFFBQVEsQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQztTQUMvQixDQUFDO0lBQ04sQ0FBQztDQUFBO0FBRUQsU0FBZSx1QkFBdUIsQ0FBQyxRQUFpQjs7UUFDcEQsMENBQTBDO1FBQzFDLE1BQU0sV0FBVyxHQUFHLE1BQU0sa0NBQWtDLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1FBQ3RGLElBQUksV0FBVztZQUFFLE9BQU8sV0FBVyxDQUFDO1FBRXBDLE1BQU0sVUFBVSxHQUFHLE1BQU0sa0NBQWtDLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1FBQ3BGLElBQUksVUFBVTtZQUFFLE9BQU8sVUFBVSxDQUFDO1FBRWxDLElBQUksUUFBUSxLQUFLLFNBQVMsRUFBRTtZQUN4QixNQUFNLElBQUksS0FBSyxDQUNYLDREQUE0RCxRQUFRLFlBQVksQ0FDbkYsQ0FBQztTQUNMO1FBRUQsNEJBQTRCO1FBQzVCLE1BQU0sSUFBSSxHQUFHLHFEQUFxRCxDQUFDO1FBQ25FLE1BQU0sb0JBQW9CLEdBQUcsTUFBTSxJQUFBLCtCQUFxQixFQUFDLElBQUksQ0FBQyxDQUFDO1FBQy9ELElBQUksb0JBQW9CLEVBQUU7WUFDdEIsT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxDQUFDO1NBQzFDO1FBRUQseUNBQXlDO1FBQ3pDLE1BQU0sUUFBUSxHQUFHLE1BQU0sc0JBQXNCLEVBQUUsQ0FBQztRQUNoRCxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsQ0FBQztJQUMvRCxDQUFDO0NBQUE7QUFFUSwwREFBdUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBQYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0ICogYXMgb3MgZnJvbSAnb3MnO1xuaW1wb3J0IGRlYnVnIGZyb20gJ2RlYnVnJztcbmltcG9ydCB7IHJlYWRJbmlGaWxlIH0gZnJvbSAnLi91dGlscy9pbmknO1xuaW1wb3J0IHsgcmVhZFJlZ2lzdHJ5VmFsdWUgfSBmcm9tICcuL3V0aWxzL3JlZ2lzdHJ5JztcbmltcG9ydCB7IGNoZWNrSWZOYW1lZFBpcGVFeGlzdCB9IGZyb20gJy4vdXRpbHMvbmV0d29yayc7XG5cbmNvbnN0IGxvZ2dlciA9IGRlYnVnKCdub2RlLXNpbWNvbm5lY3QnKTtcblxuYXN5bmMgZnVuY3Rpb24gZmluZFNpbUNvbm5lY3RQb3J0SVB2NCgpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBvcnQgPSBhd2FpdCByZWFkUmVnaXN0cnlWYWx1ZShcbiAgICAgICAgICAgICdIS0NVXFxcXFNvZnR3YXJlXFxcXE1pY3Jvc29mdFxcXFxNaWNyb3NvZnQgR2FtZXNcXFxcRmxpZ2h0IFNpbXVsYXRvcicsXG4gICAgICAgICAgICAnU2ltQ29ubmVjdF9Qb3J0X0lQdjQnXG4gICAgICAgICk7XG4gICAgICAgIGlmICghcG9ydCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCBTaW1Db25uZWN0X1BvcnRfSVB2NCBpbiB0aGUgV2luZG93cyByZWdpc3RyeScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZUludChwb3J0LCAxMCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICAgIHJldHVybiAyMDQ4O1xuICAgIH1cbn1cblxuZXhwb3J0IHR5cGUgQ29ubmVjdGlvblBhcmFtZXRlcnMgPVxuICAgIHwgeyB0eXBlOiAncGlwZSc7IGFkZHJlc3M6IHN0cmluZyB9XG4gICAgfCB7IHR5cGU6ICdpcHY0JzsgaG9zdDogc3RyaW5nOyBwb3J0OiBudW1iZXIgfTtcblxuYXN5bmMgZnVuY3Rpb24gcmVhZE5ldHdvcmtDb25maWdGcm9tU2ltQ29ubmVjdENmZyhcbiAgICBmb2xkZXJQYXRoOiBzdHJpbmcsXG4gICAgaW5kZXg/OiBudW1iZXJcbik6IFByb21pc2U8Q29ubmVjdGlvblBhcmFtZXRlcnMgfCB1bmRlZmluZWQ+IHtcbiAgICBjb25zdCBmaWxlUGF0aCA9IFBhdGguam9pbihmb2xkZXJQYXRoLCAnU2ltQ29ubmVjdC5jZmcnKTtcblxuICAgIGxldCBmdWxsQ2ZnO1xuICAgIHRyeSB7XG4gICAgICAgIC8vIFNpbUNvbm5lY3QuY2ZnIHVzZXMgdGhlIElOSSBmaWxlZm9ybWF0XG4gICAgICAgIGZ1bGxDZmcgPSBhd2FpdCByZWFkSW5pRmlsZShmaWxlUGF0aCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsb2dnZXIoJ0NvdWxkIG5vdCByZWFkIFNpbUNvbm5lY3QuY2ZnIGR1ZSB0byB0byB0aGUgZm9sbG93aW5nIGVycm9yOicsIGUpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmIChmdWxsQ2ZnLlNpbUNvbm5lY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgU2ltQ29ubmVjdC5jZmcgZmlsZTogJHtmaWxlUGF0aH1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbmRleFN0ciA9IGluZGV4ICE9PSB1bmRlZmluZWQgPyBpbmRleC50b1N0cmluZygxMCkgOiAnMCc7XG4gICAgY29uc3QgY2ZnID0gZnVsbENmZy5TaW1Db25uZWN0W2luZGV4U3RyXSA/IGZ1bGxDZmcuU2ltQ29ubmVjdFtpbmRleFN0cl0gOiBmdWxsQ2ZnLlNpbUNvbm5lY3Q7XG5cbiAgICBpZiAoY2ZnLlByb3RvY29sID09PSB1bmRlZmluZWQgfHwgY2ZnLkFkZHJlc3MgPT09IHVuZGVmaW5lZCB8fCBjZmcuUG9ydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGxvYWRlZCBTaW1Db25uZWN0LmNmZyAoJHtmaWxlUGF0aH0pIGlzIG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVycy5gKTtcbiAgICB9IGVsc2UgaWYgKGNmZy5Qcm90b2NvbCAmJiBjZmcuUHJvdG9jb2wudG9VcHBlckNhc2UoKSAhPT0gJ0lQVjQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT25seSB0aGUgSXB2NCBwcm90b2NvbCBpcyBzdXBwb3J0ZWQgYXQgdGhlIG1vbWVudCcpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdpcHY0JyxcbiAgICAgICAgaG9zdDogY2ZnLkFkZHJlc3MsXG4gICAgICAgIHBvcnQ6IHBhcnNlSW50KGNmZy5Qb3J0LCAxMCksXG4gICAgfTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gYXV0b2RldGVjdFNlcnZlckFkZHJlc3MoY2ZnSW5kZXg/OiBudW1iZXIpOiBQcm9taXNlPENvbm5lY3Rpb25QYXJhbWV0ZXJzPiB7XG4gICAgLy8gQ2hlY2sgZm9yIFNpbUNvbm5lY3QuY2ZnIGluIGN1cnJlbnQgZGlyXG4gICAgY29uc3QgbG9jYWxDb25maWcgPSBhd2FpdCByZWFkTmV0d29ya0NvbmZpZ0Zyb21TaW1Db25uZWN0Q2ZnKHByb2Nlc3MuY3dkKCksIGNmZ0luZGV4KTtcbiAgICBpZiAobG9jYWxDb25maWcpIHJldHVybiBsb2NhbENvbmZpZztcblxuICAgIGNvbnN0IGhvbWVDb25maWcgPSBhd2FpdCByZWFkTmV0d29ya0NvbmZpZ0Zyb21TaW1Db25uZWN0Q2ZnKG9zLmhvbWVkaXIoKSwgY2ZnSW5kZXgpO1xuICAgIGlmIChob21lQ29uZmlnKSByZXR1cm4gaG9tZUNvbmZpZztcblxuICAgIGlmIChjZmdJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBObyBTaW1Db25uZWN0LmNmZyBmaWxlIGNvbnRhaW5pbmcgdGhlIGdpdmVuIGNvbmZpZyBpbmRleCAke2NmZ0luZGV4fSB3YXMgZm91bmRgXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgbmFtZWQgcGlwZSBleGlzdFxuICAgIGNvbnN0IFBJUEUgPSAnXFxcXFxcXFwuXFxcXHBpcGVcXFxcTWljcm9zb2Z0IEZsaWdodCBTaW11bGF0b3JcXFxcU2ltQ29ubmVjdCc7XG4gICAgY29uc3QgbXNmc1NpbWNvbm5lY3RQaXBlT2sgPSBhd2FpdCBjaGVja0lmTmFtZWRQaXBlRXhpc3QoUElQRSk7XG4gICAgaWYgKG1zZnNTaW1jb25uZWN0UGlwZU9rKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdwaXBlJywgYWRkcmVzczogUElQRSB9O1xuICAgIH1cblxuICAgIC8vIFJlYWQgcG9ydCBudW1iZXIgZnJvbSBXaW5kb3dzIHJlZ2lzdHJ5XG4gICAgY29uc3QgaXB2NHBvcnQgPSBhd2FpdCBmaW5kU2ltQ29ubmVjdFBvcnRJUHY0KCk7XG4gICAgcmV0dXJuIHsgdHlwZTogJ2lwdjQnLCBob3N0OiAnbG9jYWxob3N0JywgcG9ydDogaXB2NHBvcnQgfTtcbn1cblxuZXhwb3J0IHsgYXV0b2RldGVjdFNlcnZlckFkZHJlc3MgfTtcbiJdfQ==